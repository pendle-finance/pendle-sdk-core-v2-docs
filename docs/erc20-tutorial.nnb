{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "_**Caution**_: In this notebook, we are using a dummy address. If you wish to see a more natural result without the risk of losing money, please specify your own address and change the chain ID to testnet ID (for example, `43113` for Fuji).\n\n---"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "There are a few kinds of entities in Pendle SDK, and ERC20 is one of them. The entities have similar functionalities, and ERC20 is the most straightforward and common entity. So let’s take a look at Pendle SDK’s functionalities with ERC20."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "# Entity creation"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Let’s say we want to interact with the USDC contract on Ethereum. USDC contract has address `0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48`."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "const USDCAddress = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48';"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "To communicate with the contract, we also need a provider and/or signer."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { Wallet, getDefaultProvider } from 'ethers';\n\nconst dummyMnemonic = 'test test test test test test test test test test test junk';\n\nconst provider = getDefaultProvider();\nconst wallet = Wallet.fromMnemonic(dummyMnemonic).connect(provider);\nconst signer = wallet;"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Here we did not pass any parameters to ethers' [`getDefaultProvider()`](https://docs.ethers.io/v5/api/providers/#providers-getDefaultProvider). By default, the network will be **mainnet**."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { ERC20 } from '@pendle/sdk-v2';\n\n\n// ERC20 entity with read-only functionalities\nconst readonlyErc20 = new ERC20(USDCAddress, { provider });\n\n// ERC20 entity with read-write functionalities\nconst readWriteErc20 = new ERC20(USDCAddress, { signer });"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Other entities have roughly the same constructor signature: \n- the contract address,\n- the entity configuration, including the network connection."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "The network connection parameter inside the entity configuration should be an object that has either the property provider: `ethers.providers.Provider`, or `signer: ethers.Signer`. Pass signer if all contract functionalities are required. Otherwise, just pass in a provider. If both provider and signer are presented, the signer must be connected to the passed-in provider (an error will be thrown otherwise)."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "const provider = getDefaultProvider();\nconst unconnectedWallet = Wallet.createRandom();\nconst connectedWallet = unconnectedWallet.connect(provider);\n\nconst contractAddress = USDCAddress;\n\n// The following constructions work fine\nnew ERC20(contractAddress, { provider });\nnew ERC20(contractAddress, { signer: connectedWallet });\nnew ERC20(contractAddress, { signer: unconnectedWallet });\nnew ERC20(contractAddress, { provider, signer: connectedWallet });\n\n// The following construction will throw an error\ntry {\n    new ERC20(contractAddress, { provider, signer: unconnectedWallet });  // Error\n} catch (e) {\n    console.log('Got error');\n    console.log(e);\n}"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "Got error",
                                "PendleSdkError: For contract creation, networkConnection.provider should be the same as networkConnection.signer.provider",
                                "    at createContractObject (/home/darkkcyan/projects/pendle-sdk-core-v2-docs/node_modules/@pendle/sdk-v2/src/contracts/createContractObject.ts:160:15)",
                                "    at new PendleEntity (/home/darkkcyan/projects/pendle-sdk-core-v2-docs/node_modules/@pendle/sdk-v2/src/entities/PendleEntity.ts:29:26)",
                                "    at new ERC20 (/home/darkkcyan/projects/pendle-sdk-core-v2-docs/node_modules/@pendle/sdk-v2/src/entities/ERC20.ts:18:9)",
                                "    at <Cell 13> [15, 13]",
                                "    at <Cell 13> [18, 46]",
                                "    at Script.runInContext (node:vm:141:12)",
                                "    at Script.runInNewContext (node:vm:146:17)",
                                "    at Object.runInNewContext (node:vm:306:38)",
                                "    at C (/home/darkkcyan/.vscode-oss/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:113345)",
                                "    at t.execCode (/home/darkkcyan/.vscode-oss/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:114312)",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "# Read-only functions"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "An `ERC20` has the following read-only functions:\n```solidity\nfunction name() public view returns (string);\nfunction symbol() public view returns (string);\nfunction decimals() public view returns (uint8);\nfunction totalSupply() public view returns (uint256);\nfunction balanceOf(address _owner) public view returns (uint256 balance);\nfunction allowance(address _owner, address _spender) public view returns (uint256 remaining);\n```"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "You can use these functions similarly to calling them in a contract:"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { Address } from '@pendle/sdk-v2';\n\nasync function readonlyFunctionsExample(erc20: ERC20, ownerAddress: Address, spenderAddress: Address) {\n    const name = await erc20.name();\n    const symbol = await erc20.symbol();\n    \n    // convert ethersjs' BigNumber to string for readability\n    const decimals = (await erc20.decimals()).toString();\n    const totalSupply = (await erc20.totalSupply()).toString();\n    const balanceOf = (await erc20.balanceOf(ownerAddress)).toString();\n    const allowance = (await erc20.allowance(ownerAddress, spenderAddress)).toString();\n    return {ownerAddress, spenderAddress, name, symbol, decimals, totalSupply, balanceOf, allowance };\n}"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "To demonstrate the usage of the example, we need addresses of an owner and a spender. For example, we can use the address of [this transaction](https://etherscan.io/tx/0x5678b37a0acda9b248d242173b9a43a869b8ff81ee6d9b8f4ec387cf640edc65):\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "const ownerAddress: Address = '0x5cb656d7605d9924c085fc859585f3ff2f7ad08f';\nconst spenderAddress: Address = '0x221b0a202d7926fc1b9257310b5a16592f2ab852';"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "await readonlyFunctionsExample(readonlyErc20, ownerAddress, spenderAddress);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "{",
                                "  ownerAddress: \u001b[32m'0x5cb656d7605d9924c085fc859585f3ff2f7ad08f'\u001b[39m,",
                                "  spenderAddress: \u001b[32m'0x221b0a202d7926fc1b9257310b5a16592f2ab852'\u001b[39m,",
                                "  name: \u001b[32m'USD Coin'\u001b[39m,",
                                "  symbol: \u001b[32m'USDC'\u001b[39m,",
                                "  decimals: \u001b[32m'6'\u001b[39m,",
                                "  totalSupply: \u001b[32m'40157324583559550'\u001b[39m,",
                                "  balanceOf: \u001b[32m'0'\u001b[39m,",
                                "  allowance: \u001b[32m'0'\u001b[39m",
                                "}"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "The function `readonlyFunctionsExample` sends the calls _sequentially_. To send the all the calls to the provider at the same time, use `Promise.all`."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "async function readonlyFunctionExamplePromiseAll(erc20: ERC20, ownerAddress: string, spenderAddress: string) {\n    const [name, symbol, decimals, totalSupply, balanceOf, allowance] = await Promise.all([\n        erc20.name(),\n        erc20.symbol(),\n        \n        // convert ethersjs' BigNumber to string for readability\n        erc20.decimals().then(String),\n        erc20.totalSupply().then(String),\n        erc20.balanceOf(ownerAddress).then(String),\n        erc20.allowance(ownerAddress, spenderAddress).then(String),\n    ]);\n    return {ownerAddress, spenderAddress, name, symbol, decimals, totalSupply, balanceOf, allowance };\n}"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "await readonlyFunctionExamplePromiseAll(readonlyErc20, ownerAddress, spenderAddress);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "{",
                                "  ownerAddress: \u001b[32m'0x5cb656d7605d9924c085fc859585f3ff2f7ad08f'\u001b[39m,",
                                "  spenderAddress: \u001b[32m'0x221b0a202d7926fc1b9257310b5a16592f2ab852'\u001b[39m,",
                                "  name: \u001b[32m'USD Coin'\u001b[39m,",
                                "  symbol: \u001b[32m'USDC'\u001b[39m,",
                                "  decimals: \u001b[32m'6'\u001b[39m,",
                                "  totalSupply: \u001b[32m'40157324583559550'\u001b[39m,",
                                "  balanceOf: \u001b[32m'0'\u001b[39m,",
                                "  allowance: \u001b[32m'0'\u001b[39m",
                                "}"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "## Multicall support"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Pendle SDK supports calling read-only functions with [Multicall](https://github.com/makerdao/multicall) by makerdao. Multicall is the preferred way to call multiple contract methods at once to reduce the round trips over the network. To use multicall, first create a Multicall instance as follows:"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { Multicall } from '@pendle/sdk-v2';\n\nconst multicall = new Multicall({ chainId: 1, provider });"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "`chainId` and `provider` are the required parameters. The `chainId` is `1`, as we are querying the Ethereum network. There are two more optional parameters:\n\n- `callLimit: number` (default: `64`), the maximum number of calls per multicall request.\n- `blockTag: string` (default: `latest`), the block tag for the multicall requests."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### Passing multicall to entity constructor"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "ERC20 entity’s contractor’s third parameter also accept multicall. You can pass in `multicall` to ERC20 as follows:"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "const readonlyErc20WithMulticall = new ERC20(USDCAddress, { provider, multicall });"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "After that, you can use it as in readonlyFunctionExamplePromiseAll, and Pendle SDK will handle the batching for you:"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "await readonlyFunctionExamplePromiseAll(readonlyErc20WithMulticall, ownerAddress, spenderAddress);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "{",
                                "  ownerAddress: \u001b[32m'0x5cb656d7605d9924c085fc859585f3ff2f7ad08f'\u001b[39m,",
                                "  spenderAddress: \u001b[32m'0x221b0a202d7926fc1b9257310b5a16592f2ab852'\u001b[39m,",
                                "  name: \u001b[32m'USD Coin'\u001b[39m,",
                                "  symbol: \u001b[32m'USDC'\u001b[39m,",
                                "  decimals: \u001b[32m'6'\u001b[39m,",
                                "  totalSupply: \u001b[32m'40157324583559550'\u001b[39m,",
                                "  balanceOf: \u001b[32m'0'\u001b[39m,",
                                "  allowance: \u001b[32m'0'\u001b[39m",
                                "}"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Note that `readonlyFunctionsExample` will not work with multicall, as the methods are called sequentially. If used with an ERC20 entity that is initialized with a multicall instance, each call will be a multicall request with a single call inside instead!"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### Passing multicall to the methods"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "If an ERC20 entity was not initialized with `multicall`, it can still be called with multicall by passing the `multicall` instance to the methods as the last parameter:"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "async function readonlyFunctionExample_multicallToMethods(\n    erc20: ERC20,\n    ownerAddress: string,\n    spenderAddress: string,\n    multicall?: Multicall\n) {\n    const [name, symbol, decimals, totalSupply, balanceOf, allowance] = await Promise.all([\n        erc20.name({ multicall }),\n        erc20.symbol({ multicall }),\n        \n        // convert ethersjs' BigNumber to string for readability\n        erc20.decimals({ multicall }).then(String),\n        erc20.totalSupply({ multicall }).then(String),\n        erc20.balanceOf(ownerAddress, { multicall }).then(String),\n        erc20.allowance(ownerAddress, spenderAddress, { multicall }).then(String),\n    ]);\n    return {ownerAddress, spenderAddress, name, symbol, decimals, totalSupply, balanceOf, allowance };\n}"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "await readonlyFunctionExample_multicallToMethods(\n    readonlyErc20WithMulticall,\n    ownerAddress,\n    spenderAddress,\n    multicall\n);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "{",
                                "  ownerAddress: \u001b[32m'0x5cb656d7605d9924c085fc859585f3ff2f7ad08f'\u001b[39m,",
                                "  spenderAddress: \u001b[32m'0x221b0a202d7926fc1b9257310b5a16592f2ab852'\u001b[39m,",
                                "  name: \u001b[32m'USD Coin'\u001b[39m,",
                                "  symbol: \u001b[32m'USDC'\u001b[39m,",
                                "  decimals: \u001b[32m'6'\u001b[39m,",
                                "  totalSupply: \u001b[32m'40157324583559550'\u001b[39m,",
                                "  balanceOf: \u001b[32m'0'\u001b[39m,",
                                "  allowance: \u001b[32m'0'\u001b[39m",
                                "}"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Again, Pendle SDK will handle all the batching. And also `readonlyFunctionsExample` will also not work for the same reason as above."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "When `multicall` parameter is `undefined`, it will have the same effect as `readonlyFunctionExamplePromiseAll` (without `multicall`)."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "await readonlyFunctionExample_multicallToMethods(\n    readonlyErc20WithMulticall,\n    ownerAddress,\n    spenderAddress\n    // No multicall here\n);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "{",
                                "  ownerAddress: \u001b[32m'0x5cb656d7605d9924c085fc859585f3ff2f7ad08f'\u001b[39m,",
                                "  spenderAddress: \u001b[32m'0x221b0a202d7926fc1b9257310b5a16592f2ab852'\u001b[39m,",
                                "  name: \u001b[32m'USD Coin'\u001b[39m,",
                                "  symbol: \u001b[32m'USDC'\u001b[39m,",
                                "  decimals: \u001b[32m'6'\u001b[39m,",
                                "  totalSupply: \u001b[32m'40157324583559550'\u001b[39m,",
                                "  balanceOf: \u001b[32m'0'\u001b[39m,",
                                "  allowance: \u001b[32m'0'\u001b[39m",
                                "}"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "# Write functions"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Caution**: The following functions might modify the contract state. To prevent this, we define the following variable. Set it to true to run the write methods. As we are using Typescript, the example is guaranteed to have the correct typing."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "const ACTUALLY_RUN_WRITE_FUNCTION = false;"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "function guardWrite<A extends any[], R>(fn: (...params: A) => R): (...params: A) => R | undefined {\n    return (...params: A) => {\n        if (!ACTUALLY_RUN_WRITE_FUNCTION) {\n            console.log(\"Please set ACTUALLY_RUN_WRITE_FUNCTION to true to run the function\");\n            return undefined;\n        }\n        return fn(...params);\n    };\n}"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "---\n\nAn `ERC20` has the following write functions:\n```solidity\nfunction approve(address _spender, uint256 _value) public returns (bool success);\nfunction transfer(address _to, uint256 _value) public returns (bool success);\n```"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "As the read-only function, you can also use these functions similarly to calling them in a contract:"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { BigNumberish } from '@pendle/sdk-v2';\n\nconst writeFunctionExample = guardWrite(async (\n    erc20: ERC20,\n    spenderAddress: string,\n    rawAmount: BigNumberish\n) => {\n    await erc20.approve(spenderAddress, rawAmount);\n    await erc20.transfer(spenderAddress, rawAmount);\n});"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "To run the function, we need `spenderAddress`, as well as an `amount`."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "const spenderAddress = '0x221b0a202d7926fc1b9257310b5a16592f2ab852';\nconst amount = 0;"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "await writeFunctionExample(readWriteErc20, spenderAddress, amount);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "Please set ACTUALLY_RUN_WRITE_FUNCTION to true to run the function",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "In `writeFunctionExample`, two transactions will be sent. The first one is a approve transaction. After the first one is done, another transaction, with is transfer is sent."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Meta-methods"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Sometimes we don’t want to make a change to the network, but we only want to see the hypothetical results, or we want to estimate the amount of gas used. Ethers.js allows doing these actions directly via [`callStatic`](https://docs.ethers.io/v5/api/contract/contract/#contract-callStatic) and [`estimateGas`](https://docs.ethers.io/v5/api/contract/contract/#contract-estimateGas) *[meta classes](https://docs.ethers.io/v5/api/contract/contract/#Contract--metaclass)*. Pendle SDK also allows doing these actions via the *meta-method*. Each write function also accepts an additional parameter, which is `MetaMethodType`, defined as follows:\n\n```ts\ntype MetaMethodType = 'send' | 'callStatic' | 'estimateGas' | 'meta-method' | 'multicallStatic';\n```"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### `send` meta-method"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "This meta-method is the default behavior for a method call, which is to perform a transaction"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { Overrides } from 'ethers'; \n\nconst writeFunctionExample_sendMetaMethod = guardWrite(async (\n    erc20: ERC20,\n    spenderAddress: string,\n    rawAmount: BigNumberish,\n    overrides?: Overrides\n) => {\n    await erc20.approve(spenderAddress, rawAmount, { method: 'send', overrides });\n    await erc20.transfer(spenderAddress, rawAmount, { method: 'send', overrides });\n});"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "await writeFunctionExample_sendMetaMethod(readWriteErc20, spenderAddress, amount);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "Please set ACTUALLY_RUN_WRITE_FUNCTION to true to run the function",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "`writeFunctionExample_sendMetaMethod` does the same thing as `writeFunctionExample`."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### `callStatic` meta-method"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Use this meta-method to ask a node to execute the contract and return the hypothetical results of the method."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "async function writeFunctionExample_callStaticMetaMethod(\n    erc20: ERC20,\n    spenderAddress: string,\n    rawAmount: BigNumberish,\n    overrides?: Overrides\n) {\n    const isApproved = await erc20.approve(spenderAddress, rawAmount, { method: 'callStatic', overrides });\n    const transferable = await erc20.transfer(spenderAddress, rawAmount, { method: 'callStatic', overrides });\n    return { isApproved, transferable };\n}"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "await writeFunctionExample_callStaticMetaMethod(readWriteErc20, spenderAddress, amount);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "{",
                                "  isApproved: \u001b[33mtrue\u001b[39m,",
                                "  transferable: \u001b[33mtrue\u001b[39m",
                                "}"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### `multicallStatic` meta-method\n\nThis is the same as `callStatic` but with Multicall. Note that `multicall` effects only happen for this meta-method if the entity is initialized with `Multicall`. If you want to pass a multicall instance to the method call, see [`meta-method` meta-method.](https://www.notion.so/ERC20-contract-interaction-tutorial-with-Pendle-SDK-db0bd481eed541cd88c5f226887d8600)"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "async function writeFunctionExample_multicallStaticMetaMethod(\n     erc20: ERC20,\n     spenderAddress: string,\n     amount: BigNumberish,\n     multicall?: Multicall\n) {\n    const [isApproved, transferable] = await Promise.all([\n        erc20.approve(spenderAddress, amount, { method: 'multicallStatic', multicall }),\n        erc20.transfer(spenderAddress, amount, { method: 'multicallStatic', multicall })\n    ]);\n    return { isApproved, transferable };\n}"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "await writeFunctionExample_multicallStaticMetaMethod(readWriteErc20, spenderAddress, amount, multicall);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "{",
                                "  isApproved: \u001b[33mtrue\u001b[39m,",
                                "  transferable: \u001b[33mtrue\u001b[39m",
                                "}"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### `estimateGas` meta-method\nUse this meta method to estimate the amount of gas consumed for the method calls."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "async function writeFunctionExample_estimateGasMetaMethod(\n    erc20: ERC20,\n    spenderAddress: Address,\n    amount: BigNumberish,\n    overrides?: Overrides\n) {\n    const approveGasUsed = String(await erc20.approve(spenderAddress, amount, {\n        method: 'estimateGas',\n        overrides\n    }));\n    const transferGasUsed = String(await erc20.transfer(spenderAddress, amount, {\n        method: 'estimateGas',\n        overrides\n    }));\n    return { approveGasUsed, transferGasUsed };\n}"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "await writeFunctionExample_estimateGasMetaMethod(readWriteErc20, spenderAddress, amount);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "{",
                                "  approveGasUsed: \u001b[32m'40160'\u001b[39m,",
                                "  transferGasUsed: \u001b[32m'43348'\u001b[39m",
                                "}"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "### `meta-method` meta-method\nTo have more control over the write method, meta-method can be used."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "async function writeFunctionExample_metaMethodMetaMethod(\n    erc20: ERC20,\n    spenderAddress: string,\n    amount: BigNumberish,\n    multicall?: Multicall,\n    overrides?: Overrides\n) {\n    const metaMethod = await erc20.approve(spenderAddress, amount, { method: 'meta-method' });\n\n    const isApproved = await metaMethod.callStatic(overrides);\n    const isApprovedWithMulticall = await metaMethod.multicallStatic({ multicall });\n    const gasUsed = String(await metaMethod.estimateGas(overrides));\n    \n    console.log({\n        isApproved,\n        isApprovedWithMulticall,\n        gasUsed,\n    });\n        \n    // actually perform the transaction\n    await guardWrite(\n        () => metaMethod.send(overrides)\n    )();  \n}"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "await writeFunctionExample_metaMethodMetaMethod(readWriteErc20, spenderAddress, amount);"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "{ isApproved: true, isApprovedWithMulticall: true, gasUsed: '40160' }",
                                "Please set ACTUALLY_RUN_WRITE_FUNCTION to true to run the function",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "# Other functionalities"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## The inner contract\n\nERC20 entity has a property called `contract: WrappedContract<PendleERC20>`. `PendleERC20` is the contract interface generated to be compatible with ethers.js’s `Contract` object via [`@typechain/hardhat`](https://www.npmjs.com/package/@typechain/hardhat) plugin. `WrappedContract` is our custom type that wraps around the generated interface to have additional functionalities, such as catching Pendle contract errors and calling contracts with multicall and meta-methods. See [`WrappedContract`](https://www.notion.so/Pendle-SDK-s-WrappedContract-18444f7d35d6411b87ce487812be4b58) // TODO fix link."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { WrappedContract, PendleERC20 } from '@pendle/sdk-v2';\n\nconst wrappedContract: WrappedContract<PendleERC20> = readWriteErc20.contract;"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "\n## Setting the ABI\n\nIf you wish to extend `ERC20` classes with a different contract ABI, you can set the ABI via the constructor configuration parameters. The ABI should have a compatible type with the `ERC20` ABI. Be careful to do otherwise, as Pendle SDK does not check to ABI compatibility."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { PendlePrincipalTokenABI, ChainId, NetworkConnection } from '@pendle/sdk-v2';\n\nfunction createErc20ForPT(\n    address: Address,\n    chainId: ChainId,\n    networkConnection: NetworkConnection\n) {\n    return new ERC20(address, chainId, { ...networkConnection, abi: PendlePrincipalTokenABI });\n}"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "The `contract` property, however, will still be `WrappedContract<PendleERC20>`. If you know the correct type, you can cast it to that type.\n\nIf you wish to create a subclass of `ERC20`, you can do as follows:"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { PendlePrincipalToken } from '@pendle/sdk-v2';\n\nclass ERC20ForPT extends ERC20 {\n    // ...\n    \n    get contract(): WrappedContract<PendlePrincipalToken> {\n        return this._contract as WrappedContract<PendlePrincipalToken>;\n    }\n}"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "This is exactly what is done under the hood of Pendle SDK, as `PendlePrincipalToken` does indeed extend `PendleERC20` on the contract side. See PtEntity (TODO link)."
            ],
            "outputs": []
        }
    ]
}