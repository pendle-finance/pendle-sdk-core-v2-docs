{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "# Pendle SDK’s WrappedContract\n\n---"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Pendle SDK is built on top of [Ethers](https://docs.ethers.io/v5/). While being versatile, Ethers lacks some specific functionalities, such as calling contracts with multicall and catching our contract’s errors. Using Ethers’ Contract objects directly is often less reusable, as sometimes we want to estimate the consumed gas, or get the result instead of making a transaction, but with the same logic as making the transaction. To solve these problems, we decided to make wrap Ethers’ Contract object to create a high-level object, making the contract interaction process more convenient. "
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Usage"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### WrappedContract creation\n\nTo create a `WrappedContract` , use the function `createContractObject`. In the following example, contract objects for the USDC token."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { createContractObject, toAddress } from '@pendle/sdk-v2';\nimport { PendleERC20, PendleERC20ABI } from '@pendle/sdk-v2';\nimport { getDefaultProvider, Wallet } from 'ethers';\n\nconst USDCAddress = toAddress('0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48');\nconst provider = getDefaultProvider();\nconst signer = Wallet.createRandom().connect(provider);\nconst chainId = 1;\n\nconst readonlyWrappedContract = createContractObject<PendleERC20>(USDCAddress, PendleERC20ABI, { provider }); \nconst readWriteWrappedContract = createContractObject<PendleERC20>(USDCAddress, PendleERC20ABI, { signer });"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "This function accepts a type parameter `C`, which is the generated contract’s typechain type. Next is the contract’s addresses, and its ABI. The final parameter is the configuration.\n\nThe configuration has the `signer` and `provider` similar to the configuration of `PendleEntity`. See [ERC20 contract interaction tutorial with Pendle SDK](./erc20-tutorial.nnb), as well as the `NetworkConnection` type in [Utilities types and functions](./utilities-types-and-functions.nnb).\nBy default, this function returns `WrappedContract<C>`, but it can also return ethersjs’ Contract, if `doWrap: false` is passed to the configuration. "
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Will have type PendleERC20 instead of WrappedContract<PendleERC20>\nconst ethersJsContract: PendleERC20 = createContractObject<PendleERC20>(USDCAddress, PendleERC20ABI, { signer, doWrap: false });"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### Basic contract interaction\n\nA `WrappedContract` object also has *the same* meta classes as ethersjs’ Contract, and they can be used the same way! Here is an example for the read function."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { Address, BigNumberish } from '@pendle/sdk-v2';\n\nasync function exampleReadFunctions(contract: ContractLike<PendleERC20>, user1: Address, user2: Address) {\n  // call methods right from the contract object\n  const user1Balance = (await contract.balanceOf(user1)).toString();\n  const symbol = await contract.symbol();\n  const name = await contract.name();\n  \n  // call static\n  const user2Balance = (await contract.callStatic.balanceOf(user2)).toString();\n\n  // estimate gas\n  const allowanceGasUsed = (await contract.estimateGas.allowance(user1, user2)).toString();\n  return {\n    user1Balance,\n    user2Balance,\n    symbol,\n    name,\n    allowanceGasUsed, \n  };\n}\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "To see the functions in action, we can use the following addresses got from the [top USDC holder page](https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48#balances)"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "const user1 = toAddress('0x0a59649758aa4d66e25f08dd01271e891fe52199');\nconst user2 = toAddress('0xf977814e90da44bfa03b6295a0616a897441acec');"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// works with both Ethersjs' Contract and WrappedContract\n\ntry {\n    console.log('readonly wrapped contract', await exampleReadFunctions(readonlyWrappedContract, user1, user2));\n    console.log('read write wrapped contract', await exampleReadFunctions(readWriteWrappedContract, user1, user2));\n    console.log('ehtersjs contract', await exampleReadFunctions(ethersJsContract, user1, user2));\n} catch (e) {\n    console.error(e);\n}"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "readonly wrapped contract {",
                                "  user1Balance: '2319142746596521',",
                                "  user2Balance: '1470056996991000',",
                                "  symbol: 'USDC',",
                                "  name: 'USD Coin',",
                                "  allowanceGasUsed: '31726'",
                                "}",
                                "read write wrapped contract {",
                                "  user1Balance: '2319142746596521',",
                                "  user2Balance: '1470056996991000',",
                                "  symbol: 'USDC',",
                                "  name: 'USD Coin',",
                                "  allowanceGasUsed: '31726'",
                                "}",
                                "ehtersjs contract {",
                                "  user1Balance: '2319142746596521',",
                                "  user2Balance: '1470056996991000',",
                                "  symbol: 'USDC',",
                                "  name: 'USD Coin',",
                                "  allowanceGasUsed: '31726'",
                                "}",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "The write function can also be done in the same way. But please done run it if you don't intend to!"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "async function exampleWriteFunctions(contract: ContractLike<PendleERC20>, receiver: Address, amount: BigNumberish) {\n  // functions\n  await contract.functions.approve(receiver, amount);\n\n  // call methods right from the contract object\n  await contract.transfer(receiver, amount);\n}\n\n// exampleWriteFunctions(readWriteWrappedContract, user1, tesAmount);\n// exampleWriteFunctions(ethersJsContract, user1, testAmount);"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Though the interfaces are the same, there is a key difference: when there is an error, Pendle SDK will throw a custom error, especially for Pendle Contracts. See [Error handling](./error-handling.nnb).\n\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### Multicall support — The `multicallStatic` meta-class.\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { Multicall } from '@pendle/sdk-v2';"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "\nThe `WrappedContract` object has an additional meta-class called `multicallStatic`. It has the same function as the `callStatic` meta-class, but the signature is a bit different.\n\nThe signature of a `callStatic` method will have the following form:\n\n```ts\ncallStaticMethod(arg1, arg2, ..., overrides?: Override): Promise<Result>;\n```\n\nThe signature of a `multicallStatic` method will have the following form instead:\n\n```ts\nmulticallStaticMethod(arg1, arg2, ..., multicallStaticParams?: MulticallStaticParams): Promise<Result>;\n```\n\nwhere\n```ts\ntype MulticallStaticParams = {\n    multicall?: Multicall;\n    overrides?: CallOverrides\n};\n```\n\nThe `multicallStatic` is guaranteed to work **correctly**. If `multicall` is not specified, the methods of this meta-class will act as `callStatic`.\n\nSimilarly to a `PendleEntity`, like our `ERC20` entity (see [ERC20 contract interaction tutorial with Pendle SDK](./erc20-tutorial.nnb)), there are two way to use `multicall`.\n\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### Initialize the `WrappedContract` with `Multicall`\n\nPass the `Multicall` instance to the configuration of `createContractObject`. Then use `multicallStatic` to have the *batching* effects of multicall."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "async function wrappedContractWithMulticall(contractAddress: Address, userAddress: Address) {\n  const multicall = new Multicall({ chainId, provider });\n\tconst contract = createContractObject<PendleERC20>(contractAddress, PendleERC20ABI, {\n    provider,\n    multicall  // pass it here\n  });\n  \n  const [name, symbol, decimals, userBalance] = await Promise.all([\n    contract.multicallStatic.name(),\n    contract.multicallStatic.symbol(),\n    contract.multicallStatic.decimals(),\n    contract.multicallStatic.balanceOf(userAddress),\n  ]);\n  return { name, symbol, decimals, userBalance: userBalance.toString()};\n}"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "try {\n    console.log(await wrappedContractWithMulticall(USDCAddress, user1));\n} catch (e) {\n    console.error(e);\n}"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "{",
                                "  name: 'USD Coin',",
                                "  symbol: 'USDC',",
                                "  decimals: 6,",
                                "  userBalance: '2318276066921088'",
                                "}",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Note that `Promise.all` should be used to have the *batching* effect.\n\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### Pass `Multicall` to `multicallStatic` methods\n\n`Multicall` instance can also be passed to the calling methods."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "async function wrappedContractWithMulticall(contractAddress: Address, userAddress: Address) {\n  const multicall = new Multicall({ chainId, provider });\n\tconst contract = createContractObject<PendleERC20>(contractAddress, PendleERC20ABI, {\n    provider,\n  });\n  \n  const [name, symbol, decimals, userBalance] = await Promise.all([\n    contract.multicallStatic.name(multicall),\n    contract.multicallStatic.symbol(multicall),\n    contract.multicallStatic.decimals(multicall),\n    contract.multicallStatic.balanceOf(userAddress, multicall),\n  ]);\n  return { name, symbol, decimals, userBalance: userBalance.toString()};\n}"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "try {\n    console.log(await wrappedContractWithMulticall(USDCAddress, user1));\n} catch (e) {\n    console.error(e);\n}"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "{",
                                "  name: 'USD Coin',",
                                "  symbol: 'USDC',",
                                "  decimals: 6,",
                                "  userBalance: '2318276066921088'",
                                "}",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "**Note**: if the contract is already initialized with `Multicall`, but another `Multicall` instance is passed into the `multicallStatic` methods, **the passed one will be used**. So one `WrappedContract` instance can be used with different `Multicall` instance in different contexts.\n\nWe encourage using the _wass `Multicall` to `multicallStatic` methods_ style for developing new functions, as the contract can always be called with the user’s defined `Multicall` in different contexts.\n\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### Meta-methods — the `metaCall` meta class.\n\nSimilar to an ERC20 entity, all PendleEntity classes will support calling write functions with meta-methods. See [ERC20 contract interaction tutorial with Pendle SDK](./erc20-tutorial.nnb), the Meta-methods section for examples.\n\nTo aid the development of these write functions, `WrappedContract` methods can also be called directly with meta-methods via the meta-class `metaCall`. \n\nThe methods of `metaCall` will have the following signature:\n\n```tsx\ncontract.metaCall.methodName(arg1, arg2, ..., metaMethodType?: MetaMethodExtraParam): MetaMethodReturnType;\n```\n\nwhere\n```ts\ntype MetaMethodExtraParams<T extends MetaMethodType = 'send'> = MulticallStaticParams & {\n    method?: T;\n    gasLimitBufferingPercent?: number;\n};\n\ntype MetaMethodType = 'send' | 'callStatic' | 'estimateGas' | 'meta-method' | 'multicallStatic';\n```\n\nand `MetaMethodReturnType` is a helper type that will be defined for each `MetaMethodType`."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Here is a table for the actual return type for each `MetaMethodType`.\n\n| MetaMethodType | The meta-class to be mimicked | Specific return type |\n| --- | --- | --- |\n| `send` | `contract.functions` | `Promise<ContractTransaction>` for write-methods. `Promise<R>` for read-methods. |\n| `callStatic` | `contract.callStatic` | `Promise<R>` |\n| `estimateGas` | `contract.estimateGas` | `Promise<BigNumber>` |\n| `multicallStatic` | `contract.multicallStatic` | `Promise<R>` |\n| `meta-method` | `contract.metaCall` | `ContractMetaMethod` |\n\nHere `Promise<R>` is the return type of the contract methods. For example, for ERC20 contract, `balanceOf` will return `Promise<BigNumber>`, `name()` and `symbol()` will return `Promise<string>`.\n\nWhen the `metaMethodType` is `undefined`, the method act like `send.`\n\nSee [`type MetaMethodReturnType`](http://playground.pendle.finance/sdk-docs/types/MetaMethodReturnType.html) for more formal specification of `MetaMethodReturnType`, and [`class ContractMetaMethod`](http://playground.pendle.finance/sdk-docs/classes/ContractMetaMethod.html) for additional features of `ContractMetaMethod`.\n\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### Quick example"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "async function metaCallExample(contract: WrappedContract<PendleERC20>) {\n  const user1 = \"<address here>\", user2 = \"<address here>\";\n  const amount = \"<bignumber amount here>\";\n\n\t// send example\n  await contract.metaCall.approve(user1, amount, { method: 'call' });\n  await contract.metaCall.approve(user1, amount);  // do the same as the above.\n\n  // call static example\n  const allowance = await contract.metaCall.allowance(user1, user2, { method: 'callStatic' });\n\n  // multicallStatic example\n  const [name, symbol, decimals, totalSuply] = await Promise.all([\n    contract.metaCall.name({ method: 'multicallStatic'}),\n    contract.metaCall.symbol({ method: 'multicallStatic' }),\n    contract.metaCall.decimals({ method: 'multicallStatic' }),\n    contract.metaCall.totalSupply({ method: 'multicallStatic' })\n  ]);\n\n  // estimateGas example\n  const transferGasUsed = await contract.metaCall.transfer(user1, amount, { method: 'estimateGas' });\n  \n  // meta-method example\n\n  const transferMetaMethod = await contract.metaCall.transfer(user1, amount, { method: 'meta-method' });\n  {\n    // use with callStatic.\n    const remaning = await transferMetaMethod.callStatic();\n    // use with estimateGas.\n    const gasUsed = await transferMetaMethod.estimateGas();\n    await transferMetaMethod.send();\n    // can also be used to send again.\n    await transferMetaMethod.send();\n  }\n}"
            ],
            "outputs": []
        }
    ]
}