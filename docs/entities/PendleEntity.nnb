{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "# PendleEntity\n\n--- \n\nThis is the base class of all entities class of Pendle SDK. It is not intended to be used directly, but to be overridden."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Example subclass\n\nHere is a small example to create a custom subclass of `PendleEntity`."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import {\n    // PendleEntity\n    PendleEntity, PendleEntityConfigOptionalAbi,\n\n    // ERC20 typechain type and abi, with WrappedContract type\n    PendleERC20, PendleERC20ABI, WrappedContract,\n\n    // Types for parameters\n    Address, BigNumberish, BN,\n\n    // MulticallStaticParams for read-methods\n    MulticallStaticParams,\n\n    // Meta method related types for write-methods\n    MetaMethodType, MetaMethodExtraParams\n} from '@pendle/sdk-v2';\n\n/**\n * Override the config\n */\nexport type MyERC20Config = PendleEntityConfigOptionalAbi;\n\n\nclass MyERC20 extends PendleEntity {\n    constructor(\n        readonly address: Address,\n        config: MyERC20Config   // use the custom config\n    ) {\n        super(\n            address,\n            {\n                // passing in the abi\n                // but does not overwrite the abi of the config\n                abi: PendleERC20ABI,\n                ...config\n            });\n    }\n\n    /**\n     * Override the getter to return the correct type with type case\n     */\n    get contract(): WrappedContract<PendleERC20> {\n        return this._contract as WrappedContract<PendleERC20>;\n    }\n\n    /**\n     * Example read method\n     */\n    allowance(\n        // required params\n        owner: Address,\n        spender: Address,\n\n        // read methods should mostly be used with multicall\n        // via `this.contract.multicallStatic`. Hence this param\n        params?: MulticallStaticParams & { /* your custom param here */ }\n    ): Promise<BN> {\n        return this.contract.multicallStatic.allowance(\n            owner,\n            spender,\n            params   // remember to pass in params\n        );\n    }\n\n    /**\n     * Example write method\n     * Read methods should be used with meta method.\n     * The type parameter T is required so tsc can detect the correct return type\n     * \n     * Meta method often has complex return type, so we can left tsc to determine the return type for us.\n     * \n     * But in this case, the return type will be\n     * \n     *  RouterMetaMethodReturnType<T, PendleERC20, 'approve', MetaMethodExtraParams<T>>\n     */\n\n    async approve<T extends MetaMethodType>(\n        // required params\n        spender: Address,\n        amount: BigNumberish,\n\n        // overall params for meta method\n        params: MetaMethodExtraParams<T> & { /* your custom params here */ } = {}\n    ) {\n        return this.contract.metaCall.approve(\n            spender,\n            amount,\n            this.addExtraParams(params)      // remember to pass in params\n        );\n    }\n}\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Utility types"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### type `PendleEntityConfigOptionalAbi`"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { PendleEntityConfigOptionalAbi } from '@pendle/sdk-v2';"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "```ts\ntype PendleEntityConfigOptionalAbi = NetworkConnection & {\n    multicall?: Multicall;\n    abi?: ContractInterface;\n};\n```\n\nThis type is used base configuration for a `PendleEntity`, but is mainly used for the subclass of `PendleEntity`, as the subclass will pass its contract ABI to the class `PendleEntity`.\n\nSee `NetworkConnection` in [Utilities types and functions](https://www.notion.so/Utilities-types-and-functions-3c28e12657514a01884d29ce0faae4e6).\n\nPass in `Multicall` to use contract methods with `Multicall` (via `multicallStatic`)."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### type `PendleEntityConfig`"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { PendleEntityConfig } from '@pendle/sdk-v2';"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "```ts\ntype PendleEntityConfig = PendleEntityConfigOptionalAbi & {\n    abi: ContractInterface;\n};\n```\n\nThis is the same type as `PendleEntityConfigOptionalAbi`, but with forced ABI."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## class `PendleEntity`"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { PendleEntity } from '@pendle/sdk-v2';"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "```ts\nclass PendleEntity\n```"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### constructor\n\n```tsx\nconstructor(\n\taddress: Address,\n\tconfig: PendleEntityConfig\n)\n```\n\n##### Parameters\n- `address: Address` — The inner contract address\n- `config: PendleEntityConfig` — the configuration.\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### Properties and methods"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### `_contract`\n```ts\nprotected readonly _contract: WrappedContract\n```\n\nThe _wrapped_ contract that the entity is holding. This should not be used directly. Instead the getter `contract` should be used to have the correct _type_ of the wrapped contract.\n\nSee [`WrappedContract`](../WrappedContract.nnb)."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### `contract`\n```ts\nget contract(): WrappedContract\n```\nThis getter returns `this._contract` but with the casted type. It is intended to be overridden in the subclasses."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### `multicall`\n```ts\nreadonly multicall?: Multicall;\n```\n\nThe `Multicall` instance used by this entity. See [`Multicall`](TODO) <span style='color: red'>TODO link</span>"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### `networkConnection`\n\n```ts\nreadonly networkConnection: NetworkConnection;\n```\n\nThe `networkConnection` of this entity. See [Utilities types and functions](../utilities-types-and-functions.nnb)."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### `entityConfig`\n```\nget entityConfig(): PendleEntityConfigOptionalAbi;\n```\n\nThis getter returns the config of the current entity. It can be used to pass as configuration for a new entity. It should be overridden in the subclass."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### `getDefaultMetaMethodExtraParam()`\n\n```ts\ngetDefaultMetaMethodExtraParams<T extends MetaMethodType>(): MetaMethodExtraParams<T>;\n```\n\n**Please see [`WrappedContract`](../WrappedContract.nnb) first.**\n\nReturn the set of parameters for an entity's write-method (that will do a `metaCall`). It should be overridden in the subclass."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### `addExtraParams()`\n\n```ts\naddExtraParams<T extends MetaMethodType>(params: MetaMethodExtraParams<T>): MetaMethodExtraParams<T>;\n```\n\n**Please see [`WrappedContract`](../WrappedContract.nnb) first.**\n\nMerge user-defined parameters with the default parameters (from `getDefaultMetaMethodExtraParam()`) and return the result to use use in a write method."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Function documentation template\n\nIn the subclasses of PendleEntity, there are read and write functions, with take complex additional parameters, and return complex return type. Fortunately, these parameters, as well as the return types, have the same shape. The following are the template of these function."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### Read function template"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "```ts\nfunctionName(arg1: T1, arg2: T2, ..., params?: MulticallStaticParams): Promise<R>\n```\n\n##### Parameters\n- `arg1`: T1\n- `arg2`: T2\n- `params?`: [MulticallStaticParams] - the additional parameters for read method. See [WrappedContract](../WrappedContract.nnb) for more details.\n\n##### Returns\n`R`\n\n[Address]: ../utilities-types-and-functions.nnb\n[MulticallStaticParams]: ../WrappedContract.nnb\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### Write function template"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "```ts\nfunctionName<T extends MetaMethodType>(\n    arg1: T1,\n    arg2: T2,\n    params: MetaMethodExtraParams<T> = {}\n): MetaMethodReturnType<\n    T,\n    C, // the contract type\n    'methodName',\n    MetaMethodExtraParams<T>\n>;\n```\n\n##### Type parameters\n- `T` extends [MetaMethodType]: The type of the meta method. This should be infer by `tsc` to determine the correct return type. See [ERC20 contract interaction tutorial with Pendle SDK][ERC20-tutorial] to see the example usage with explanation. See [WrappedContract](../WrappedContract.nnb) for more details.\n\n##### Parameters\n- `params?`: [MetaMethodExtraParams<T>][MetaMethodExtraParams] - the additional parameters for **write** method. See [WrappedContract](../WrappedContract.nnb) for more details.\n\n##### Returns\nWhen `params` is not defined, or when `params.method` is not defined, this method will perform the transaction, and return `Promise<ethers.ContractTransaction>`.\n\nOtherwise, `params.method`'s value is used to determine the return type:\n- for `'send'`, this method will perform the transaction, and return `Promise<ethers.ContractTransaction>`.\n- for `'estimateGas'`, this method will estimate the gas required to send the transaction, and return `Promise<BN>`.\n- for `'callStatic'` and `'multicallStatic'`, this method will \nask a node to perform the contract method, and return the result, without changing the contract's state, then return `Promise<???>`.\n- for `meta-method`, this method will just perform the required calculation, and return `Promise<ContractMetaMethod<C, 'methodName', MetaMethodExtraParams<T>>>`. The `data` field of the awaited result is a copy of `params`, and will have the following fields:\n    - `multicall?`: [Multicall] - the multicall instance.\n    - `overrides?`: `ethers.CallOverrides` - the overrides. This can overridden with `params.overrides`.\n    - `method`: The meta-method type. In this case it will be `meta-method`, the same value as `params.method`.\n\n\n\n\n[MetaMethodType]: ../WrappedContract.nnb\n[Address]: ../utilities-types-and-functions.nnb\n[MulticallStaticParams]: ../WrappedContract.nnb\n[MetaMethodExtraParams]: ../WrappedContract.nnb\n[Multicall]: ../Multicall.nnb\n[ERC20-tutorial]: ../erc20-tutorial.nnb"
            ],
            "outputs": []
        }
    ]
}